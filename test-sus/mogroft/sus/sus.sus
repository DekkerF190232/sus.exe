
package sus/Math {

  static real32 PI = 3.14159265359;
  static real32 2PI = 6.28318530718;

  func CON(cdecl) real32 powf(real32 base, real32 power) EXT;
  func CON(cdecl) real32 tan(real32 x) EXT;
  func CON(cdecl) real32 sinf(real32 x) EXT;
  func CON(cdecl) real32 cosf(real32 x) EXT;
  func CON(cdecl) int32 pow(int32 base, int32 power) EXT;
  
}

package sus/native/Win {

  # math
  func CON(cdecl) real32 powf(real32 base, real32 power) EXT;
  func CON(cdecl) int32 pow(int32 base, int32 power) EXT;

  # strings
  func CON(cdecl) int32 strnlen(PTR[int8] buffer, int32 size) EXT;
  func CON(cdecl) _itoa_s(int32 value, PTR[int8] buffer, int32 size, int32 radix) EXT;

  # stdout
  static int32 STD_OUTPUT_HANDLE = -11;
  func CON(stdcall) ExitProcess(int32 code) EXT;
  func CON(stdcall) int32 GetStdHandle(int32 handle) EXT;
  func CON(stdcall) boo WriteFile(int32 file, PTR[int8] buffer, int32 length, PTR[int32] written, PTR[ptr] overlapped) EXT;

  # errors
  func CON(stdcall) SetLastError(int32 code) EXT;
  func CON(stdcall) int32 GetLastError() EXT;

  # threads
  func CON(stdcall) Sleep(int32 ms) EXT;
  
  # windows
  
  #
  # VK_0 - VK_9 are the same as ASCII '0' - '9' (0x30 - 0x39)
  # 0x3A - 0x40 : unassigned
  # VK_A - VK_Z are the same as ASCII 'A' - 'Z' (0x41 - 0x5A)
  #
  static int32 VK_LBUTTON        = @01;
  static int32 VK_RBUTTON        = @02;
  static int32 VK_CANCEL         = @03;
  static int32 VK_MBUTTON        = @04;
  static int32 VK_XBUTTON1       = @05;
  static int32 VK_XBUTTON2       = @06;
  static int32 VK_BACK           = @08;
  static int32 VK_TAB            = @09;
  static int32 VK_CLEAR          = @0C;
  static int32 VK_RETURN         = @0D;
  static int32 VK_SHIFT          = @10;
  static int32 VK_CONTROL        = @11;
  static int32 VK_MENU           = @12;
  static int32 VK_PAUSE          = @13;
  static int32 VK_CAPITAL        = @14;
  static int32 VK_KANA           = @15;
  static int32 VK_HANGEUL        = @15;
  static int32 VK_HANGUL         = @15;
  static int32 VK_IME_ON         = @16;
  static int32 VK_JUNJA          = @17;
  static int32 VK_FINAL          = @18;
  static int32 VK_HANJA          = @19;
  static int32 VK_KANJI          = @19;
  static int32 VK_IME_OFF        = @1A;
  static int32 VK_ESCAPE         = @1B;
  static int32 VK_CONVERT        = @1C;
  static int32 VK_NONCONVERT     = @1D;
  static int32 VK_ACCEPT         = @1E;
  static int32 VK_MODECHANGE     = @1F;
  static int32 VK_SPACE          = @20;
  static int32 VK_PRIOR          = @21;
  static int32 VK_NEXT           = @22;
  static int32 VK_END            = @23;
  static int32 VK_HOME           = @24;
  static int32 VK_LEFT           = @25;
  static int32 VK_UP             = @26;
  static int32 VK_RIGHT          = @27;
  static int32 VK_DOWN           = @28;
  static int32 VK_SELECT         = @29;
  static int32 VK_PRINT          = @2A;
  static int32 VK_EXECUTE        = @2B;
  static int32 VK_SNAPSHOT       = @2C;
  static int32 VK_INSERT         = @2D;
  static int32 VK_DELETE         = @2E;
  static int32 VK_HELP           = @2F;
  static int32 VK_LWIN           = @5B;
  static int32 VK_RWIN           = @5C;
  static int32 VK_APPS           = @5D;
  static int32 VK_SLEEP          = @5F;
  static int32 VK_NUMPAD0        = @60;
  static int32 VK_NUMPAD1        = @61;
  static int32 VK_NUMPAD2        = @62;
  static int32 VK_NUMPAD3        = @63;
  static int32 VK_NUMPAD4        = @64;
  static int32 VK_NUMPAD5        = @65;
  static int32 VK_NUMPAD6        = @66;
  static int32 VK_NUMPAD7        = @67;
  static int32 VK_NUMPAD8        = @68;
  static int32 VK_NUMPAD9        = @69;
  static int32 VK_MULTIPLY       = @6A;
  static int32 VK_ADD            = @6B;
  static int32 VK_SEPARATOR      = @6C;
  static int32 VK_SUBTRACT       = @6D;
  static int32 VK_DECIMAL        = @6E;
  static int32 VK_DIVIDE         = @6F;
  static int32 VK_F1             = @70;
  static int32 VK_F2             = @71;
  static int32 VK_F3             = @72;
  static int32 VK_F4             = @73;
  static int32 VK_F5             = @74;
  static int32 VK_F6             = @75;
  static int32 VK_F7             = @76;
  static int32 VK_F8             = @77;
  static int32 VK_F9             = @78;
  static int32 VK_F10            = @79;
  static int32 VK_F11            = @7A;
  static int32 VK_F12            = @7B;
  static int32 VK_F13            = @7C;
  static int32 VK_F14            = @7D;
  static int32 VK_F15            = @7E;
  static int32 VK_F16            = @7F;
  static int32 VK_F17            = @80;
  static int32 VK_F18            = @81;
  static int32 VK_F19            = @82;
  static int32 VK_F20            = @83;
  static int32 VK_F21            = @84;
  static int32 VK_F22            = @85;
  static int32 VK_F23            = @86;
  static int32 VK_F24            = @87;
  static int32 VK_NAVIGATION_VIEW     = @88;
  static int32 VK_NAVIGATION_MENU     = @89;
  static int32 VK_NAVIGATION_UP       = @8A;
  static int32 VK_NAVIGATION_DOWN     = @8B;
  static int32 VK_NAVIGATION_LEFT     = @8C;
  static int32 VK_NAVIGATION_RIGHT    = @8D;
  static int32 VK_NAVIGATION_ACCEPT   = @8E;
  static int32 VK_NAVIGATION_CANCEL   = @8F;
  static int32 VK_NUMLOCK        = @90;
  static int32 VK_SCROLL         = @91;
  static int32 VK_OEM_NEC_EQUAL  = @92;
  static int32 VK_OEM_FJ_JISHO   = @92;
  static int32 VK_OEM_FJ_MASSHOU = @93;
  static int32 VK_OEM_FJ_TOUROKU = @94;
  static int32 VK_OEM_FJ_LOYA    = @95;
  static int32 VK_OEM_FJ_ROYA    = @96;
  static int32 VK_LSHIFT         = @A0;
  static int32 VK_RSHIFT         = @A1;
  static int32 VK_LCONTROL       = @A2;
  static int32 VK_RCONTROL       = @A3;
  static int32 VK_LMENU          = @A4;
  static int32 VK_RMENU          = @A5;
  static int32 VK_BROWSER_BACK        = @A6;
  static int32 VK_BROWSER_FORWARD     = @A7;
  static int32 VK_BROWSER_REFRESH     = @A8;
  static int32 VK_BROWSER_STOP        = @A9;
  static int32 VK_BROWSER_SEARCH      = @AA;
  static int32 VK_BROWSER_FAVORITES   = @AB;
  static int32 VK_BROWSER_HOME        = @AC;
  static int32 VK_VOLUME_MUTE         = @AD;
  static int32 VK_VOLUME_DOWN         = @AE;
  static int32 VK_VOLUME_UP           = @AF;
  static int32 VK_MEDIA_NEXT_TRACK    = @B0;
  static int32 VK_MEDIA_PREV_TRACK    = @B1;
  static int32 VK_MEDIA_STOP          = @B2;
  static int32 VK_MEDIA_PLAY_PAUSE    = @B3;
  static int32 VK_LAUNCH_MAIL         = @B4;
  static int32 VK_LAUNCH_MEDIA_SELECT = @B5;
  static int32 VK_LAUNCH_APP1         = @B6;
  static int32 VK_LAUNCH_APP2         = @B7;
  static int32 VK_OEM_1          = @BA;
  static int32 VK_OEM_PLUS       = @BB;
  static int32 VK_OEM_COMMA      = @BC;
  static int32 VK_OEM_MINUS      = @BD;
  static int32 VK_OEM_PERIOD     = @BE;
  static int32 VK_OEM_2          = @BF;
  static int32 VK_OEM_3          = @C0;
  static int32 VK_GAMEPAD_A                         = @C3;
  static int32 VK_GAMEPAD_B                         = @C4;
  static int32 VK_GAMEPAD_X                         = @C5;
  static int32 VK_GAMEPAD_Y                         = @C6;
  static int32 VK_GAMEPAD_RIGHT_SHOULDER            = @C7;
  static int32 VK_GAMEPAD_LEFT_SHOULDER             = @C8;
  static int32 VK_GAMEPAD_LEFT_TRIGGER              = @C9;
  static int32 VK_GAMEPAD_RIGHT_TRIGGER             = @CA;
  static int32 VK_GAMEPAD_DPAD_UP                   = @CB;
  static int32 VK_GAMEPAD_DPAD_DOWN                 = @CC;
  static int32 VK_GAMEPAD_DPAD_LEFT                 = @CD;
  static int32 VK_GAMEPAD_DPAD_RIGHT                = @CE;
  static int32 VK_GAMEPAD_MENU                      = @CF;
  static int32 VK_GAMEPAD_VIEW                      = @D0;
  static int32 VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON    = @D1;
  static int32 VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON   = @D2;
  static int32 VK_GAMEPAD_LEFT_THUMBSTICK_UP        = @D3;
  static int32 VK_GAMEPAD_LEFT_THUMBSTICK_DOWN      = @D4;
  static int32 VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT     = @D5;
  static int32 VK_GAMEPAD_LEFT_THUMBSTICK_LEFT      = @D6;
  static int32 VK_GAMEPAD_RIGHT_THUMBSTICK_UP       = @D7;
  static int32 VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN     = @D8;
  static int32 VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT    = @D9;
  static int32 VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT     = @DA;
  static int32 VK_OEM_4          = @DB;
  static int32 VK_OEM_5          = @DC;
  static int32 VK_OEM_6          = @DD;
  static int32 VK_OEM_7          = @DE;
  static int32 VK_OEM_8          = @DF;
  static int32 VK_OEM_AX         = @E1;
  static int32 VK_OEM_102        = @E2;
  static int32 VK_ICO_HELP       = @E3;
  static int32 VK_ICO_00         = @E4;
  static int32 VK_PROCESSKEY     = @E5;
  static int32 VK_ICO_CLEAR      = @E6;
  static int32 VK_PACKET         = @E7;
  static int32 VK_OEM_RESET      = @E9;
  static int32 VK_OEM_JUMP       = @EA;
  static int32 VK_OEM_PA1        = @EB;
  static int32 VK_OEM_PA2        = @EC;
  static int32 VK_OEM_PA3        = @ED;
  static int32 VK_OEM_WSCTRL     = @EE;
  static int32 VK_OEM_CUSEL      = @EF;
  static int32 VK_OEM_ATTN       = @F0;
  static int32 VK_OEM_FINISH     = @F1;
  static int32 VK_OEM_COPY       = @F2;
  static int32 VK_OEM_AUTO       = @F3;
  static int32 VK_OEM_ENLW       = @F4;
  static int32 VK_OEM_BACKTAB    = @F5;
  static int32 VK_ATTN           = @F6;
  static int32 VK_CRSEL          = @F7;
  static int32 VK_EXSEL          = @F8;
  static int32 VK_EREOF          = @F9;
  static int32 VK_PLAY           = @FA;
  static int32 VK_ZOOM           = @FB;
  static int32 VK_NONAME         = @FC;
  static int32 VK_PA1            = @FD;
  static int32 VK_OEM_CLEAR      = @FE;
  
  struct LargeInteger (
    int32 low,
    int32 high
  );
  func LargeInteger new_LargeInteger() {
    done LargeInteger( low = 0, high = 0 );
  }
  
  static int32 DPI_AWARENESS_CONTEXT_UNAWARE              = -1;
  static int32 DPI_AWARENESS_CONTEXT_SYSTEM_AWARE         = -2;
  static int32 DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE    = -3;
  static int32 DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2 = -4;
  static int32 DPI_AWARENESS_CONTEXT_UNAWARE_GDISCALED    = -5;
  
  func CON(stdcall) int32 SetThreadDpiAwarenessContext(int32 dpiAwarenessContext) EXT;
  
  func CON(stdcall) int32 SetTimer(
    WindowHandle  handle,
    int32         timerId,
    int32         intervalMs,
    funcptr[CON(stdcall) (WindowHandle handle, int32 _unnamed1, int32 _unnamed2, int32 _unnamed3)]
                  timerFunc
  ) EXT;
  
  func CON(stdcall) boo InvalidateRect(WindowHandle handle, PTR[Rectangle] rectangle, boo erase) EXT;

  struct Rectangle (
    int32 left,
    int32 top,
    int32 right,
    int32 bottom
  );

  func CON(stdcall) boo AdjustWindowRect(PTR[Rectangle] rectangle, int32 style, boo menu) EXT;

  func CON(stdcall) WindowHandle CreateWindowExA(
    int32 extendedStyle,
    PTR[int8] className,
    PTR[int8] windowName,
    int32 style,
    int32 x,
    int32 y,
    int32 width,
    int32 height,
    WindowHandle parentHandle,
    MenuHandle menu,
    InstanceHandle instance,
    ptr param) EXT;

  static int32 WS_OVERLAPPED       = @00000000;
  static int32 WS_POPUP            = @80000000;
  static int32 WS_CHILD            = @40000000;
  static int32 WS_MINIMIZE         = @20000000;
  static int32 WS_VISIBLE          = @10000000;
  static int32 WS_DISABLED         = @08000000;
  static int32 WS_CLIPSIBLINGS     = @04000000;
  static int32 WS_CLIPCHILDREN     = @02000000;
  static int32 WS_MAXIMIZE         = @01000000;
  static int32 WS_CAPTION          = @00C00000;
  static int32 WS_BORDER           = @00800000;
  static int32 WS_DLGFRAME         = @00400000;
  static int32 WS_VSCROLL          = @00200000;
  static int32 WS_HSCROLL          = @00100000;
  static int32 WS_SYSMENU          = @00080000;
  static int32 WS_THICKFRAME       = @00040000;
  static int32 WS_GROUP            = @00020000;
  static int32 WS_TABSTOP          = @00010000;
  static int32 WS_MINIMIZEBOX      = @00020000;
  static int32 WS_MAXIMIZEBOX      = @00010000;

  func int32 fc_WS_OVERLAPPEDWINDOW() {
    done WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
  }

  static int32 CS_VREDRAW          = @0001;
  static int32 CS_HREDRAW          = @0002;
  static int32 CS_DBLCLKS          = @0008;
  static int32 CS_OWNDC            = @0020;
  static int32 CS_CLASSDC          = @0040;
  static int32 CS_PARENTDC         = @0080;
  static int32 CS_NOCLOSE          = @0200;
  static int32 CS_SAVEBITS         = @0800;
  static int32 CS_BYTEALIGNCLIENT  = @1000;
  static int32 CS_BYTEALIGNWINDOW  = @2000;
  static int32 CS_GLOBALCLASS      = @4000;

  static int32 SWP_NOSIZE          = @0001;
  static int32 SWP_NOMOVE          = @0002;
  static int32 SWP_NOZORDER        = @0004;
  static int32 SWP_NOREDRAW        = @0008;
  static int32 SWP_NOACTIVATE      = @0010;
  static int32 SWP_FRAMECHANGED    = @0020;
  static int32 SWP_SHOWWINDOW      = @0040;
  static int32 SWP_HIDEWINDOW      = @0080;
  static int32 SWP_NOCOPYBITS      = @0100;
  static int32 SWP_NOOWNERZORDER   = @0200;
  static int32 SWP_NOSENDCHANGING  = @0400;
 
  static int32 SW_SHOWNORMAL = 1;

  struct InstanceHandle (int32 _unused);
  struct WindowHandle (int32 _unused);
  struct MenuHandle (int32 _unused);
  struct IconHandle (int32 _unused);
  struct CursorHandle (int32 _unused);
  struct BrushHandle (int32 _unused);

  func PTR[int8] fc_IDI_WINLOGO() { done RTP[PTR[int8]](32517); }
  func PTR[int8] fc_IDC_ARROW() { done RTP[PTR[int8]](32512); }
  
  static int32 ATTACH_PARENT_PROCESS = -1;
  func CON(stdcall) boo AttachConsole(int32 processId) EXT;
  
  func CON(stdcall) IconHandle LoadIconA(InstanceHandle instance, PTR[int8] iconName) EXT;

  func CON(stdcall) CursorHandle LoadCursorA(InstanceHandle instance, PTR[int8] cursorName) EXT;

  func CON(stdcall) int32 DefWindowProcA(WindowHandle handle, int32 message, int32 wParam, int32 lParam) EXT;

  struct WindowClassExtendedAscii (
    int32 cbSize,
    int32 style,
    funcptr[CON(stdcall) int32 (WindowHandle handle, int32 message, int32 wParam, int32 lParam)] 
         windowProc,
    int32 cbClsExt,
    int32 cbWndExt,
    InstanceHandle instance,
    IconHandle icon,
    CursorHandle cursor,
    BrushHandle background,
    PTR[int8] menuName,
    PTR[int8] className,
    IconHandle iconSmall
  );
  func CON(stdcall) boo ShowWindow(WindowHandle handle, int32 showCommand) EXT;
  func CON(stdcall) int16 RegisterClassExA(PTR[WindowClassExtendedAscii] windowClass) EXT;

  func CON(stdcall) boo SetWindowPos(
      WindowHandle handle,
      WindowHandle handleInsertAfter,
      int32 x,
      int32 y,
      int32 cx,
      int32 cy,
      int32 flags) EXT;

  struct Point (
    int32 x,
    int32 y
  );

  struct WindowMessage (
    WindowHandle handle,
    int32 message,
    int32 wParam,
    int32 lParam,
    int32 time,
    Point point
  );
  func WindowMessage new_WindowMessage() {
    done WindowMessage(
      handle = RTP[WindowHandle](0),
      message = 0,
      wParam = 0,
      lParam = 0,
      time = 0,
      point = Point(x = 0, y = 0)
    );
  }
  
  static int32 WM_CREATE         = @0001;
  static int32 WM_PAINT          = @000f;
  static int32 WM_SIZE           = @0005;
  static int32 WM_KILLFOCUS      = @0008;
  static int32 WM_CLOSE          = @0010;
  static int32 WM_KEYFIRST       = @0100;
  static int32 WM_KEYDOWN        = @0100;
  static int32 WM_KEYUP          = @0101;
  static int32 WM_TIMER          = @0113;

  func CON(stdcall) boo GetMessageA(PTR[WindowMessage] message, WindowHandle handle, int32 filterMin, int32 filterMax) EXT;

  func CON(stdcall) boo UpdateWindow(WindowHandle handle) EXT;
  func CON(stdcall) boo TranslateMessage(PTR[WindowMessage] message) EXT;
  func CON(stdcall) int32 DispatchMessageA(PTR[WindowMessage] message) EXT;
  
  struct GlRenderContextHandle (ptr _unused);
  
  func CON(stdcall) GlRenderContextHandle wglCreateContext(DeviceContextHandle dch) EXT;
  func CON(stdcall) boo wglMakeCurrent(DeviceContextHandle dch, GlRenderContextHandle glRenderContextHandle) EXT;
  
  func CON(stdcall) boo SetPixelFormat(DeviceContextHandle dch, int32 format, PTR[PixelFormatDescriptor] pfd) EXT;
  
  struct DeviceContextHandle(ptr _unused);

  func CON(stdcall) DeviceContextHandle GetDC(WindowHandle handle) EXT;

  struct PixelFormatDescriptor (
    int16 size,
    int16 version,
    int32 flags,
    int8 pixelType,
    int8 colorBits,
    int8 redBits,
    int8 redShift,
    int8 greenBits,
    int8 greenShift,
    int8 blueBits,
    int8 blueShift,
    int8 alphaBits,
    int8 alphaShift,
    int8 accumBits,
    int8 accumRedBits,
    int8 accumGreenBits,
    int8 accumBlueBits,
    int8 accumAlphaBits,
    int8 depthBits,
    int8 stencilBits,
    int8 auxBuffers,
    int8 layerType,
    int8 reserved,
    int32 layerMask,
    int32 visibleMask,
    int32 damageMask
  );

  func int8 fc_PFD_TYPE_RGBA() {
    done cast[int8](0);
  }

  static int32 PFD_DRAW_TO_WINDOW          = @00000004;
  static int32 PFD_SUPPORT_OPENGL          = @00000020;

  func CON(stdcall) int32 ChoosePixelFormat(
    DeviceContextHandle dch,
    PTR[PixelFormatDescriptor] pfd
  ) EXT;


  func PixelFormatDescriptor new_PixelFormatDescriptor() {
    done PixelFormatDescriptor (
      size = cast[int16](0),
      version = cast[int16](0),
      flags = 0,
      pixelType = cast[int8](0),
      colorBits = cast[int8](0),
      redBits = cast[int8](0),
      redShift = cast[int8](0),
      greenBits = cast[int8](0),
      greenShift = cast[int8](0),
      blueBits = cast[int8](0),
      blueShift = cast[int8](0),
      alphaBits = cast[int8](0),
      alphaShift = cast[int8](0),
      accumBits = cast[int8](0),
      accumRedBits = cast[int8](0),
      accumGreenBits = cast[int8](0),
      accumBlueBits = cast[int8](0),
      accumAlphaBits = cast[int8](0),
      depthBits = cast[int8](0),
      stencilBits = cast[int8](0),
      auxBuffers = cast[int8](0),
      layerType = cast[int8](0),
      reserved = cast[int8](0),
      layerMask = 0,
      visibleMask = 0,
      damageMask = 0
    );
  }

  struct PaintStruct (
    DeviceContextHandle dch,
    boo erase,
    Rectangle rectangle,
    boo restore,
    array[int8, 3] _padding1,
    boo incUpdate,
    array[int8, 3] _padding2,
    array[int8, 32] rgbReserved
  );
  
  func PaintStruct new_PaintStruct() {
    done PaintStruct (
      dch=RTP[DeviceContextHandle](0),
      erase=no,
      rectangle=Rectangle(
        left=0,
        top=0,
        right=0,
        bottom=0
      ),
      restore = no,
      _padding1 = array[int8,3](cast[int8](0)),
      incUpdate = no,
      _padding2 = array[int8, 3](cast[int8](0)),
      rgbReserved = array[int8, 32](cast[int8](0))
    );
  }
  
  func CON(stdcall) DeviceContextHandle BeginPaint(WindowHandle handle, PTR[PaintStruct] paintStruct) EXT;
  func CON(stdcall) DeviceContextHandle EndPaint(WindowHandle handle, PTR[PaintStruct] paintStruct) EXT;

  
  
  # files
  
  func CON(stdcall) boo CloseHandle(int32 handle) EXT;
  
  func CON(stdcall) boo ReadFile(
    int32 fileHandle,
    PTR[int8] buffer,
    int32 toRead,
    PTR[int32] actualRead,
    ptr overlapped
  ) EXT;
  
  # CreateFileA shareMode
  static int32 FILE_SHARE_NONE                  = @00000000;  
  static int32 FILE_SHARE_READ                  = @00000001;  
  static int32 FILE_SHARE_WRITE                 = @00000002;  
  static int32 FILE_SHARE_DELETE                = @00000004;
  
  # CreateFileA accessMode
  static int32 GENERIC_READ                     = @80000000;
  static int32 GENERIC_WRITE                    = @40000000;
  static int32 GENERIC_EXECUTE                  = @20000000;
  static int32 GENERIC_ALL                      = @10000000;
  
  # CreateFileAcreationMode
  static int32 CREATE_NEW                       = 1;
  static int32 CREATE_ALWAYS                    = 2;
  static int32 OPEN_EXISTING                    = 3;
  static int32 OPEN_ALWAYS                      = 4;
  static int32 TRUNCATE_EXISTING                = 5;
  
  # CreateFileA flagsAndAttributes
  
  func CON(stdcall) int32 CreateFileA(
    PTR[int8] fileName,
    int32 accessMode,
    int32 shareMode,
    ptr securityAttributes,
    int32 creationMode,
    int32 flagsAndAttributes,
    int32 templateFileHandle
  ) EXT;
  
  func CON(stdcall) boo GetFileSizeEx(
    int32 file,
    PTR[LargeInteger] fileSize
  ) EXT;

}

package sus/Limits {
  
  static int32 INT32_MAX = 2147483647;
  static int32 INT32_MIN = -2147483648;
  
}

package sus/Memory {
  
  func CON(cdecl) ptr malloc(int32 bytes) EXT;
  func CON(cdecl) free(ptr pointer) EXT;

}

package sus/StringStream {

  use sus/Limits;
  use sus/Memory;
  use sus/System;
  use sus/native/Win;

  struct StringStream (
    PTR[int8] buffer,
    int32 length,
    int32 position
  );
  
  func append(PTR[StringStream] stream, PTR[int8] s) {
    while (cast[int32](DRF(s)) != 0) {
      if (DRF(stream).position >= DRF(stream).length) done;
      
      DRF(DRF(stream).buffer + DRF(stream).position) = DRF(s);
      
      DRF(stream).position = DRF(stream).position + 1;
      s = s + 1;
    }
    #System/print(s: STR"Appended ");
    #System/println(i: DRF(stream).position);
  }
  
  func append(PTR[StringStream] stream, int32 i_0x) {
    append(stream: stream, i: i_0x, radix: 16);
  }
  
  func append(PTR[StringStream] stream, int32 i) {
    append(stream: stream, i: i, radix: 10);
  }
  
  func append(PTR[StringStream] stream, int32 i, int32 radix) {
    PTR[int8] buffer = ARR[int8](16);
    Win/_itoa_s(value: i, buffer: buffer, size: 16, radix: radix);
    
    append(stream: stream, s: buffer);
  }
  
  func append(PTR[StringStream] stream, real32 r) {
    append(stream: stream, r: r, digits: 10);
  }
    
  func append(PTR[StringStream] stream, real32 r, int32 digits) {
    boo neg = r < 0.0;
    real32 digitMag = Win/powf(base: 10.0, power: cast[real32](digits));

    if (neg) r = 0.0 - r;

    int32 intPart = cast[int32](r);
    int32 decPart = cast[int32]((r - cast[real32](intPart)) * digitMag);

    if (neg) append(stream: stream, s: STR"-");
    append(stream: stream, i: intPart);

    if (digits > 0) {
      append(stream: stream, s: STR".");

      PTR[int8] buffer = ARR[int8](16);
      Win/_itoa_s(value: decPart, buffer: buffer, size: 16, radix: 10);
      int32 nonZeroCount = Win/strnlen(buffer: buffer, size: 16);
      
      int32 zeros = digits - nonZeroCount;
      while (zeros > 0) {
        append(stream: stream, s: STR"0");
        zeros = zeros - 1;
      }

      append(stream:stream, s: buffer);
    }
  }
  
  #func append(PTR[StringStream] stream, int32 i) {
  #  int32 zero = cast[int32](DRF(STR"0"));
  #  
  #  boo neg = i < 0;
  #  if (neg) {
  #    if (DRF(stream).position >= DRF(stream).length) done;
  #    DRF(DRF(stream).buffer + DRF(stream).position) = DRF(STR"-");
  #    DRF(stream).position = DRF(stream).position + 1;
  #  }
  #  if (i == 0) {
  #    if (DRF(stream).position >= DRF(stream).length) done;
  #    DRF(DRF(stream).buffer + DRF(stream).position) = cast[int8](zero);
  #    DRF(stream).position = DRF(stream).position + 1;
  #  }
  #  while (i > 0) {
  #    int32 code = zero + (i % 10);
  #    
  #    if (DRF(stream).position >= DRF(stream).length) done;
  #    DRF(DRF(stream).buffer + DRF(stream).position) = cast[int8](code);
  #    DRF(stream).position = DRF(stream).position + 1;
  #    
  #    i = i / 10;
  #  }
  #}
  
}

package sus/File {

  use sus/System;
  use sus/Memory;
  use sus/native/Win;

  # gets file content of existing file or crashes if file does not exist
  func int32 read(PTR[int8] file, PTR[PTR[int8]] data) {
    #
    # open file and get size
    #
    int32 handle = Win/CreateFileA(
      fileName: file,
      accessMode: Win/GENERIC_READ,
      shareMode: Win/FILE_SHARE_NONE,
      securityAttributes: RTP[ptr](0),
      creationMode: Win/OPEN_EXISTING,
      flagsAndAttributes: 0,
      templateFileHandle: 0
    );
    if (handle == 0) {
      int32 err = Win/GetLastError();
      System/print(s: STR"Error opening file \"");
      System/print(s: file);
      System/print(s: STR"\": ");
      System/println(i: err);
      System/exit(code: err);
    }
    LargeInteger fileSize = Win/new_LargeInteger();
    boo gotSize = Win/GetFileSizeEx(
      file: handle,
      fileSize: REF(fileSize)
    );
    if (fileSize.high != 0) {
      System/print(s: STR"Error opening file \"");
      System/print(s: file);
      System/print(s: STR"\": ");
      System/println(s: STR"File to big.");
      System/exit(code: 123);
    }
    
    int32 readBytes = 0;
    DRF(data) = RTP[PTR[int8]](Memory/malloc(bytes: fileSize.low));
    boo read = Win/ReadFile(
      fileHandle: handle,
      buffer: DRF(data),
      toRead: fileSize.low,
      actualRead: REF(readBytes),
      overlapped: RTP[ptr](0)
    );
    if (read == no) {
      int32 err = Win/GetLastError();
      System/print(s: STR"Error reading file \"");
      System/print(s: file);
      System/print(s: STR"\": ");
      System/println(i: err);
      System/exit(code: err);
    }
    boo _1 = Win/CloseHandle(handle: handle);
    done readBytes;
  }

}

package sus/System {

  use sus/native/Win;
  use sus/StringStream;
  
  func print(PTR[StringStream] stream) {
    int32 i = 0;
    boo _r = Win/WriteFile(
	    file:       Win/GetStdHandle(handle: Win/STD_OUTPUT_HANDLE),
	    buffer:     DRF(stream).buffer,
	    length:     DRF(stream).position,
	    written:    RTP[PTR[int32]](0),
	    overlapped: RTP[PTR[ptr]](0)
	  );
  }
  
  func println(PTR[StringStream] stream) {
    print(stream: stream);
    println();
  }

  func sleep(int32 ms) {
    Win/Sleep(ms: ms);
  }

  func exit(int32 code) {
    Win/ExitProcess(code: code);
  }

  func print(PTR[int8] s) {
    print(s: s, length: Win/strnlen(buffer: s, size: 2147483647));
  }

  func print(PTR[int8] s, int32 length) {
    boo _r = Win/WriteFile(
	    file:       Win/GetStdHandle(handle: Win/STD_OUTPUT_HANDLE),
	    buffer:     s,
	    length:     length,
	    written:    RTP[PTR[int32]](0),
	    overlapped: RTP[PTR[ptr]](0)
	  );
  }

  func print(real32 r) {
    print(r: r, digits: 2);
  }

  func print(real32 r, int32 digits) {
    boo neg = r < 0.0;
    real32 digitMag = Win/powf(base: 10.0, power: cast[real32](digits));

    if (neg) r = 0.0 - r;

    int32 intPart = cast[int32](r);
    int32 decPart = cast[int32]((r - cast[real32](intPart)) * digitMag);

    if (neg) print(s: STR"-");
    print(i: intPart);

    if (digits > 0) {
      print(s: STR".");

      PTR[int8] buffer = ARR[int8](16);
      Win/_itoa_s(value: decPart, buffer: buffer, size: 16, radix: 10);
      int32 nonZeroCount = Win/strnlen(buffer: buffer, size: 16);
      
      int32 zeros = digits - nonZeroCount;
      while (zeros > 0) {
        print(s: STR"0");
        zeros = zeros - 1;
      }

      print(s: buffer);
    }
  }

  func print(int32 i) {
    PTR[int8] buffer = ARR[int8](16);
    Win/_itoa_s(value: i, buffer: buffer, size: 16, radix: 10);
    print(s: buffer);
  }

  func print(boo b) {
    if (b) print(s:STR"1");
    else print(s:STR"0");
  }

  func println(boo b) {
    if (b) print(s:STR"1\n");
    else print(s:STR"0\n");
  }

  func print(int32 i_0x) {
    PTR[int8] buffer = ARR[int8](16);
    Win/_itoa_s(value: i_0x, buffer: buffer, size: 16, radix: 16);
    print(s: buffer);
  }

  func println(int32 i_0x) {
    print(i_0x: i_0x);
    println();
  }

  func println(int32 i) {
    print(i: i);
    println();
  }

  func println(PTR[int8] s) {
    print(s: s);
    println();
  }

  func println() {
    print(s: STR"\n");
  }
  
  func printBytes(PTR[int8] pointer, int32 count) {
    System/print(s: STR"  ");
    int32 i = 0;
    while (i < count) {
      if (i > 0) {
        if (i % 16 == 0) System/print(s: STR"\n  ");
        else if (i % 8 == 0) System/print(s: STR" | ");
        else if (i % 4 == 0) System/print(s: STR"  ");
        else System/print(s: STR" ");
      }

      int8 byte = DRF(pointer + i);
      if (cast[int32](byte) <= @f) System/print(s: STR"0");
      System/print(i_0x: cast[int32](byte));

      i = i + 1;
    }

    System/println();
  }

}
