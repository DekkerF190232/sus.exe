
package mogroft/Renderer {

  use sus/Gl;
  use sus/System;
  use sus/Math;
  use sus/StringStream;
  
  use mogroft/Texture;
  use mogroft/Mogroft;
  use mogroft/world/World;
  
  struct RendererState (
    int32 width,
    int32 height
  );
  
  func RendererState new_RendererState() {
    done RendererState(width = 0, height = 0);
  }
  
  static int32 ticks = 0;

  func init() {
  }
  
  func render(PTR[RendererState] this, real32 dt) {
    Gl/glClear(mask: Gl/GL_COLOR_BUFFER_BIT | Gl/GL_DEPTH_BUFFER_BIT);

    Gl/glEnable(cap: Gl/GL_BLEND);
    Gl/glBlendFunc(sfactor: Gl/GL_SRC_ALPHA, dfactor: Gl/GL_ONE_MINUS_SRC_ALPHA);
    
    #color(rgba: @4060a0ff);
    #drawRec(x: -0.1, y: -0.5, width: 0.2, height: 1.0);
    #drawRec(x: -0.5, y: -0.1, width: 1.0, height: 0.2);
    #drawRec(x: -0.5, y: -0.5, width: 1.0, height: 0.2);
    #drawRec(x: 0.1, y: 0.1, width: 0.2, height: 0.5);
    
    drawWorld(this: this);
    Gl/printError(location: STR"After render");
    
    # Gl/glEnd();
    Gl/glFlush();
  }
  
  func drawWorld(PTR[RendererState] this) {
    real32 aspect = cast[real32](DRF(this).width) / cast[real32](DRF(this).height);

    # i dont know what's going on with near and far plane....
    setWorldPerspective(fov: 90.0, aspect: aspect, near: 30.0, far: 100.0); 
    
    Gl/glPushMatrix();
    
    setWorldCamera(this: this);
    
    #Gl/glRotatef(angle: 0.8, x: 1.0, y: 0.0, z: 0.0);
    #Gl/glTranslatef(x: 0.0, y: -2.0, z: -100.0);
    
    ticks = ticks + 1 % 300;
    real32 rotationPercent = cast[real32](ticks) / 300.0;
    real32 rotationDegrees = rotationPercent * 360.0;
    Gl/glRotatef(angle: rotationDegrees, x: 0.0, y: 1.0, z: 0.0);
    
    #Gl/glScalef(x: 0.5, y: 0.5, z: 0.5);
    drawCube();
    
    Gl/glPopMatrix();
  }
  
  func setWorldCamera(PTR[RendererState] this) {
    PTR[WorldState] world = REF(DRF(Mogroft/_mogroft).worldState);
    #DRF(world).player.position.z;        

    Gl/glTranslatef(x: 0.0 - DRF(world).player.position.x, y: 0.0 - DRF(world).player.position.y, z: 0.0 - DRF(world).player.position.z);
  }
  
  func setWorldPerspective(real32 fov, real32 aspect, real32 near, real32 far) {
    real32 f = 1.0 / Math/tan(x: fov * 0.5 * Math/2PI / 360.0);
    
    PTR[real32] matrix = ARR[real32](16);
    
    DRF(matrix + (size[real32]() * 0))    = f / aspect;
    DRF(matrix + (size[real32]() * 1))    = 0.0;
    DRF(matrix + (size[real32]() * 2))    = 0.0;
    DRF(matrix + (size[real32]() * 3))    = 0.0;
    
    DRF(matrix + (size[real32]() * 4))    = 0.0;
    DRF(matrix + (size[real32]() * 5))    = f;
    DRF(matrix + (size[real32]() * 6))    = 0.0;
    DRF(matrix + (size[real32]() * 7))    = 0.0;
    
    DRF(matrix + (size[real32]() * 8))    = 0.0;
    DRF(matrix + (size[real32]() * 9))    = 0.0;
    DRF(matrix + (size[real32]() * 10))   = (far + near) / (near - far);
    DRF(matrix + (size[real32]() * 11))   = (2.0 * far * near) / (near - far);
    
    DRF(matrix + (size[real32]() * 12))   = 0.0;
    DRF(matrix + (size[real32]() * 13))   = 0.0;
    DRF(matrix + (size[real32]() * 14))   = -1.0;
    DRF(matrix + (size[real32]() * 15))   = 0.0;
    
    #printMatrix(matrix: matrix);
    
    Gl/glMatrixMode(mode: Gl/GL_PROJECTION);
    Gl/glLoadIdentity();
    Gl/glMultMatrixf(matrix: matrix);
    
    Gl/glMatrixMode(mode: Gl/GL_MODELVIEW);
  }
  
  # draw 1,1,1-sized cube at 0,0,0
  func drawCube() {
    color(rgba: @ffffffff);
    
    Gl/glEnable(cap: Gl/GL_TEXTURE_2D);
    Gl/glEnable(cap: Gl/GL_DEPTH_TEST);
    Gl/glBindTexture(target: Gl/GL_TEXTURE_2D, texture: Texture/txTile1);
  
    Gl/glBegin(mode: Gl/GL_QUADS);
    
    # order front
    #
    #   0--3
    #   |  | 
    #   1--2
    
    # front face
    Gl/glTexCoord2f(u: 0.0, v: 1.0);
    Gl/glVertex3f(x: 0.0, y: 1.0, z: 1.0); # left top
    Gl/glTexCoord2f(u: 0.0, v: 0.0);
    Gl/glVertex3f(x: 0.0, y: 0.0, z: 1.0); # left bottom
    Gl/glTexCoord2f(u: 1.0, v: 0.0);
    Gl/glVertex3f(x: 1.0, y: 0.0, z: 1.0); # right bottom
    Gl/glTexCoord2f(u: 1.0, v: 1.0);
    Gl/glVertex3f(x: 1.0, y: 1.0, z: 1.0); # right top
    
    # order front
    #
    #   3--0
    #   |  | 
    #   2--1
    
    # back face
    Gl/glVertex3f(x: 1.0, y: 1.0, z: 0.0); # right top
    Gl/glVertex3f(x: 1.0, y: 0.0, z: 0.0); # right bottom
    Gl/glVertex3f(x: 0.0, y: 0.0, z: 0.0); # left bottom
    Gl/glVertex3f(x: 0.0, y: 1.0, z: 0.0); # left top
    
    Gl/glEnd();
    
    Gl/glDisable(cap: Gl/GL_DEPTH_TEST);
    Gl/glDisable(cap: Gl/GL_TEXTURE_2D);
  }
  
  func resize(PTR[RendererState] this, int32 width, int32 height) {
    DRF(this).width = width;
    DRF(this).height = height;
    Gl/glViewport(x: 0, y: 0, width: width, height: height);
  }
  
  func color(int32 rgba) {
    int32 r = rgba >> cast[int8](24) & @ff;
    int32 g = rgba >> cast[int8](16) & @ff;
    int32 b = rgba >> cast[int8](8) & @ff;
    int32 a = rgba & @ff;
    
    Gl/glColor4f(
      r: cast[real32](r) / 255.0,
      g: cast[real32](g) / 255.0,
      b: cast[real32](b) / 255.0,
      a: cast[real32](a) / 255.0
    );
  }
  
  func printMatrix(PTR[real32] matrix) {
    System/println(s: STR"4x4 Matrix:");
    int32 r = 0;
    while (r < 4) {
      int32 c = 0;
      while (c < 4) {
        PTR[real32] i = matrix + (r * 4 + c * size[real32]());
        
        PTR[int8] buffer = ARR[int8](24);
        StringStream stream = StringStream(buffer = buffer, length = 24, position = 0);
        StringStream/append(stream: REF(stream), r: DRF(i), digits: 2);
        int32 maxLength = 8;
        int32 toPad = maxLength - stream.position;
        while (toPad > 0) {
          System/print(s: STR" ");
          toPad = toPad - 1;
        }
        System/print(stream: REF(stream));
        
        System/print(s: STR"   ");
        
        c = c + 1;
      }
      System/println();
      r = r + 1;
    }
    System/println();
  }
  
  #func drawRec(real32 x, real32 y, real32 width, real32 height) {
  #  Gl/glBegin(mode: Gl/GL_QUADS);
  #  Gl/glVertex3f(x: x, y: y + height, z: 0.0); # left top
  #  Gl/glVertex3f(x: x + width, y: y + height, z: 0.0); # right top
  #  Gl/glVertex3f(x: x + width, y: y, z: 0.0); # right bottom
  #  Gl/glVertex3f(x: x, y: y, z: 0.0); # left bottom
  #  Gl/glEnd();
  #}
  

}