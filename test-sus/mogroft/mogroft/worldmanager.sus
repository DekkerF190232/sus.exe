package mogroft/world/WorldManager {

  use sus/System;
  use sus/List;
  use sus/Time;
  use sus/Thread;
  use sus/Mutex;

  use mogroft/Noise2DFractal;
  use mogroft/Noise2D;

  use mogroft/world/World;
  use mogroft/world/Block;
  use mogroft/world/Blocks;
  use mogroft/world/Chunk;
  use mogroft/world/ChunkList;
  use mogroft/world/ChunkCoordList;
  
  struct WorldManager (
    PTR[World] world,
    ChunkEventHandler chunkEventHandler,
    ChunkCoordList _queue,
    Mutex _mtxQueue,
    ChunkList _buffer,
    Mutex _mtxBuffer
  );
  
  struct ChunkEventHandler(
    funcptr[(PTR[Chunk] chunk)] onLoaded
  );

  func WorldManager new(ChunkEventHandler chunkEventHandler) {
    done WorldManager(
      world = RTP[PTR[World]](0),
      chunkEventHandler = chunkEventHandler,
      # generator
      _queue = ChunkCoordList/alloc(), 
      _mtxQueue = Mutex/alloc(),
      _buffer = ChunkList/new(),
      _mtxBuffer = Mutex/alloc()
    );
  }

  func loadExample(PTR[WorldManager] this) {
    PTR[World] world = World/alloc();
    DRF(this).world = world;

    DRF(world).player.position.z = 10.0;
    
    
    #callGenerateRange(this: this, x: 0, y: 0, z: 0, flatRange: 3, yRange: 4);

    ## Generate limited number of chunks
    #funcptr[(PTR[Chunk] chunk)] onLoadedFunc = DRF(this).chunkEventHandler.onLoaded;
    #PTR[ChunkList] chunkList = REF(DRF(world).chunkList);
    #PTR[Chunk] newChunk = RTP[PTR[Chunk]](0);
    #newChunk = ChunkList/add(this: chunkList);
    #DRF(newChunk).chunkCoord = ChunkCoord(x = 0, y = 0, z = 0);
    #generateChunk(chunk: newChunk);
    #onLoadedFunc(chunk: newChunk);
    #newChunk = ChunkList/add(this: chunkList);
    #DRF(newChunk).chunkCoord = ChunkCoord(x = 0, y = -1, z = 0);
    #generateChunk(chunk: newChunk);
    #onLoadedFunc(chunk: newChunk); 
  }
  
  func init(PTR[WorldManager] this) {
    Thread genThread = Thread/new(
      run: RTP[funcptr[(ptr param)]](funcref(_runGenerator)),
      arg: RTP[ptr](this)
    );
  }
  
  func tick(PTR[WorldManager] this, real32 dt) {
    #_unloadUnused(this: this);
    _enqueueToGenerate(this: this);
    _pollGenerated(this: this);
  }
  
  func _pollGenerated(PTR[WorldManager] this) {
    PTR[List] chunkListList = REF(DRF(DRF(this).world).chunkList.list);
    
    Mutex/lock(this: REF(DRF(this)._mtxBuffer));
    
    int32 startIndex = DRF(chunkListList).length;
    
    List/addAll(this: chunkListList, other: REF(DRF(this)._buffer.list));
    
    Mutex/unlock(this: REF(DRF(this)._mtxBuffer));
    
    funcptr[(PTR[Chunk] chunk)] onLoadedFunc = DRF(this).chunkEventHandler.onLoaded;
    List/clear(this: REF(DRF(this)._buffer.list));

    PTR[Chunk] current = RTP[PTR[Chunk]](List/at(
      this: chunkListList,
      i:    startIndex
    ));
    PTR[Chunk] addEnd = RTP[PTR[Chunk]](List/at(
      this: chunkListList,
      i:    DRF(chunkListList).length
    ));
    
    while (RTP[int32](current) != RTP[int32](addEnd)) {
      #System/println(s: STR"hi there");
      #System/fatal(reason: STR"lol");
      onLoadedFunc(chunk: current);
      current = current + size[Chunk]();
    }
  }
  
  #func _unloadUnused(PTR[WorldManager] this) {
  #}
  
  func _runGenerator(PTR[WorldManager] this) {
    PTR[ChunkCoordList] queue = REF(DRF(this)._queue);
    
    ChunkCoordList localQueue = ChunkCoordList/alloc();
    ChunkList localChunks = ChunkList/new();
    
    while (yes) {
      # transfer over chunk coord queue to this thread
      Mutex/lock(this: REF(DRF(this)._mtxQueue));
      
      List/clear(this: REF(localQueue.list));
      List/addAll(this: REF(localQueue.list), other: REF(DRF(queue).list));
      List/clear(this: REF(DRF(queue).list));
      
      Mutex/unlock(this: REF(DRF(this)._mtxQueue));
      ###
      
      #if (localQueue.list.length > 0) {      
      #  print(chunkCoordList: REF(localQueue));
      #  System/fatal(reason: STR"exit after transfer");
      #}
      
      # generate 10 chunks
      int32 end = localQueue.list.length;
      if (end > 10) end = 10;
      int32 i = 0;
      while (i < end) {
        PTR[ChunkCoord] chunkCoord = RTP[PTR[ChunkCoord]](List/at(this: REF(localQueue.list), i: i));
        PTR[Chunk] newChunk = ChunkList/add(this: REF(localChunks));
        DRF(newChunk).chunkCoord = DRF(chunkCoord);
        generateChunk(chunk: newChunk);
        i = i + 1;
      }
      ###
      
      # transfer generated chunks over to buffer
      Mutex/lock(this: REF(DRF(this)._mtxBuffer));
      
      List/addAll(this: REF(DRF(this)._buffer.list), other: REF(localChunks.list));
      List/clear(this: REF(localChunks.list));
      
      Mutex/unlock(this: REF(DRF(this)._mtxBuffer));
      ###

      Thread/sleep(ms: 10);
    }
  }
  
  func print(PTR[ChunkCoordList] chunkCoordList) {
    PTR[ChunkCoord] current = RTP[PTR[ChunkCoord]](List/at(
      this: REF(DRF(chunkCoordList).list),
      i: 0)
    );
    PTR[ChunkCoord] end = RTP[PTR[ChunkCoord]](List/at(
      this: REF(DRF(chunkCoordList).list),
      i: DRF(chunkCoordList).list.length)
    );
    System/println(s: STR"================================================================================");
    while (RTP[int32](current) != RTP[int32](end)) {
      print(chunkCoord: current);
      System/println();
      current = current + DRF(chunkCoordList).list._elementSize;
    } 
    System/println(s: STR"---------------------------------------------------------------------------------");
  }
  
  func print(PTR[ChunkCoord] chunkCoord) {
    System/print(i: DRF(chunkCoord).x);
    System/print(s: STR" ");
    System/print(i: DRF(chunkCoord).y);
    System/print(s: STR" ");
    System/print(i: DRF(chunkCoord).z);
  }
  
  func _enqueueToGenerate(PTR[WorldManager] this) {
    # generation box center
    int32 x = (cast[int32](DRF(DRF(this).world).player.position.x) + (Chunk/SIZE / 2)) / Chunk/SIZE;
    int32 y = (cast[int32](DRF(DRF(this).world).player.position.y) + (Chunk/SIZE / 2)) / Chunk/SIZE;
    int32 z = (cast[int32](DRF(DRF(this).world).player.position.z) + (Chunk/SIZE / 2)) / Chunk/SIZE;
    #System/print(r: DRF(DRF(this).world).player.position.z);
    #System/print(s: STR" ");
    #System/println(i: z);
    
    int32 flatRange = 3;
    int32 yRange = 4;
    
    PTR[ChunkList] chunkList = REF(DRF(DRF(this).world).chunkList);
    PTR[ChunkCoordList] queue = REF(DRF(this)._queue);
    
    Mutex/lock(this: REF(DRF(this)._mtxQueue));
  
    int32 cy = y - yRange;
    while (cy < (y + yRange)) {
      int32 cz = z - flatRange;
      while (cz < (z + flatRange)) {
        int32 cx = x - flatRange;
        while (cx < (x + flatRange)) {
          {
            ChunkCoord chunkCoord = ChunkCoord(x = cx, y = cy, z = cz);
          
            PTR[Chunk] loaded = ChunkList/find(
              this: chunkList,
              chunkCoord: chunkCoord
            );
            if (RTP[int32](loaded) != 0) break;
            
            PTR[ChunkCoord] enqueued = ChunkCoordList/find(
              this: queue,
              element: chunkCoord
            );
            if (RTP[int32](enqueued) != 0) break;
            
            DRF(ChunkCoordList/add(this: queue)) = chunkCoord;
            
            #System/print(s: STR"enqueued: ");
            #print(chunkCoord: REF(chunkCoord));
            #System/println();
          }
          cx = cx + 1;
        }
        cz = cz + 1;
      }
      cy = cy + 1;
    }
    
    Mutex/unlock(this: REF(DRF(this)._mtxQueue));
  }
  
  #func callGenerateRange(PTR[WorldManager] this, int32 x, int32 y, int32 z, int32 flatRange, int32 yRange) {
  #  PTR[ChunkList] chunkList = REF(DRF(DRF(this).world).chunkList);
  #  funcptr[(PTR[Chunk] chunk)] onLoadedFunc = DRF(this).chunkEventHandler.onLoaded;
  #  
  #  int32 cy = y - yRange;
  #  while (cy < (y + yRange)) {
  #    int32 cz = z - flatRange;
  #    while (cz < (z + flatRange)) {
  #      int32 cx = x - flatRange;
  #      while (cx < (x + flatRange)) {
  #        ChunkCoord chunkCoord = ChunkCoord(x = cx, y = cy, z = cz);
  #        PTR[Chunk] existing = ChunkList/find(this: chunkList, chunkCoord: chunkCoord);
  #        if (RTP[int32](existing) == 0) {
  #          PTR[Chunk] newChunk = ChunkList/add(this: chunkList);
  #          DRF(newChunk).chunkCoord = chunkCoord;
  #          generateChunk(chunk: newChunk);
  #          onLoadedFunc(chunk: newChunk);
  #        }
  #        cx = cx + 1;
  #      }
  #      cz = cz + 1;
  #    }
  #    cy = cy + 1;
  #  }
  #}

  func generateChunk(PTR[Chunk] chunk) {
    System/print(s: STR"generating: ");
    print(chunkCoord: REF(DRF(chunk).chunkCoord));
    System/println();
    
    #Time timePerlin = Time/zero();
    #int32 countPerlin = 0;
    
    PTR[Block] blocks = RTP[PTR[Block]](REF(DRF(chunk).blocks));
    int32 y = 0;
    while (y < Chunk/SIZE) {
      int32 z = 0;
      while (z < Chunk/SIZE) {
        int32 x = 0;
        while (x < Chunk/SIZE) {
          
          PTR[Block] block = blocks + (z * Chunk/SIZE * Chunk/SIZE) + (y * Chunk/SIZE) + x;
          
          int32 bx = DRF(chunk).chunkCoord.x * Chunk/SIZE + x;
          int32 by = DRF(chunk).chunkCoord.y * Chunk/SIZE + y;
          int32 bz = DRF(chunk).chunkCoord.z * Chunk/SIZE + z;
          
          if (by > 0) {
            # generate above zero
          
            DRF(block) = Blocks/BLOCK_AIR;
            x = x + 1;
            break 2;
          }
          
          # generate below zero
          
          real32 stoneHeight = 70.0;
          real32 dirtHeight = 10.0;
          real32 totalHeight = stoneHeight + dirtHeight;
          
          #Time t1 = Time/now();
          
          int32 stoney = cast[int32]((0.0 - totalHeight) + (Noise2DFractal/noise(
            x: cast[real32](bx) * 0.07,
            y: cast[real32](bz) * 0.07,
            seed: 0,
            levels: 2
          ) * stoneHeight));
          
          int32 dirty = stoney + cast[int32]((Noise2D/perlin(
            x: cast[real32](bx) * 0.07,
            y: cast[real32](bz) * 0.07,
            seed: 0
          ) * dirtHeight));
          
          #countPerlin = countPerlin + 1;
          #Time t2 = Time/now();
          #Time diff = Time/sub(a: t2, b: t1);
          #timePerlin = Time/add(a: timePerlin, b: diff);
          
          if (by < stoney) {
            DRF(block) = Blocks/BLOCK_STONE;
          } else if (by < dirty) {
            DRF(block) = Blocks/BLOCK_DIRT;
          } else {
            DRF(block) = Blocks/BLOCK_AIR;
          }
          
          x = x + 1;
        }
        
        z = z + 1;
      }
      y = y + 1;
    }
    
    #System/print(s: STR"  perlin count: ");
    #System/println(i: countPerlin);
    #System/print(s: STR"  perlin duration: ");
    #System/print(r: cast[real32](Time/mu(t: timePerlin)) / 1000000.0, digits: 6);
    #System/println();
    #timePerlin = Time/zero();
  }

}

#package mogroft/world/BatchGenerator {
#  
#  # [ ] 1. input coordinate list to generate
#  # [ ] 2. chunk buffers where they are generated
#  # [ ] 3. nevermind i will never do this lol, too much!
#  
#  struct BatchGenerator(
#    Mutex 
#  );
#  
#  func create() {
#    
#  }  
#  
#}