package mogroft/world/WorldManager {

  use sus/System;
  use sus/Time;

  use mogroft/Noise2DFractal;

  use mogroft/world/World;
  use mogroft/world/Block;
  use mogroft/world/Blocks;
  use mogroft/world/Chunk;
  use mogroft/world/ChunkList;
  use mogroft/world/ChunkCoordList;
  
  struct WorldManager (
    PTR[World] world,
    ChunkEventHandler chunkEventHandler
  );
  
  struct ChunkEventHandler(
    funcptr[(PTR[Chunk] chunk)] onLoaded
  );

  func WorldManager new(ChunkEventHandler chunkEventHandler) {
    done WorldManager(
      world = RTP[PTR[World]](0),
      chunkEventHandler = chunkEventHandler
    );
  }

  func loadExample(PTR[WorldManager] this) {
    PTR[World] world = World/alloc();
    DRF(this).world = world;

    DRF(world).player.position.z = 10.0;
    
    funcptr[(PTR[Chunk] chunk)] onLoadedFunc = DRF(this).chunkEventHandler.onLoaded;

    #PTR[ChunkList] chunkList = REF(DRF(world).chunkList);
    
    Time timeStart = Time/now();
    
    callGenerateRange(this: this, x: 0, y: 0, z: 0, flatRange: 3, yRange: 4);

    Time timeEnd = Time/now();
    System/print(s: STR"World gen duration (ms): ");
    System/println(i: Time/diff_ms(a: timeEnd, b: timeEnd));

    #PTR[Chunk] newChunk = RTP[PTR[Chunk]](0);
    #
    #newChunk = ChunkList/add(this: chunkList);
    #DRF(newChunk).chunkCoord = ChunkCoord(x = 0, y = 0, z = 0);
    #generateChunk(chunk: newChunk);
    #onLoadedFunc(chunk: newChunk);
    #
    #newChunk = ChunkList/add(this: chunkList);
    #DRF(newChunk).chunkCoord = ChunkCoord(x = 0, y = -1, z = 0);
    #generateChunk(chunk: newChunk);
    #onLoadedFunc(chunk: newChunk);
  }
  
  func callGenerateRange(PTR[WorldManager] this, int32 x, int32 y, int32 z, int32 flatRange, int32 yRange) {
    PTR[ChunkList] chunkList = REF(DRF(DRF(this).world).chunkList);
    funcptr[(PTR[Chunk] chunk)] onLoadedFunc = DRF(this).chunkEventHandler.onLoaded;
    
    #PTR[Chunk] last = RTP[PTR[Chunk]](0);
    int32 cy = y - yRange;
    while (cy < (y + yRange)) {
      int32 cz = z - flatRange;
      while (cz < (z + flatRange)) {
        int32 cx = x - flatRange;
        while (cx < (x + flatRange)) {
          #if (RTP[int32](last) != 0) {
          #  System/print(s:STR"range: ");
          #  System/print(i:DRF(last).chunkCoord.x);
          #  System/print(s:STR" ");
          #  System/print(i:DRF(last).chunkCoord.y);
          #  System/print(s:STR" ");
          #  System/print(i:DRF(last).chunkCoord.z);
          #  System/println();
          #}
          ChunkCoord chunkCoord = ChunkCoord(x = cx, y = cy, z = cz);
          PTR[Chunk] existing = ChunkList/find(this: chunkList, chunkCoord: chunkCoord);
          if (RTP[int32](existing) == 0) {
            PTR[Chunk] newChunk = ChunkList/add(this: chunkList);
            #ASM {
            #  SETTING_COORD:
            #}
            DRF(newChunk).chunkCoord = chunkCoord;
            generateChunk(chunk: newChunk);
            onLoadedFunc(chunk: newChunk);
            #if (cy == 0) last = newChunk;
          }
          cx = cx + 1;
        }
        cz = cz + 1;
      }
      cy = cy + 1;
    }
  }
  
  #func int32 noiseLevel(int32 x, int32 y, int32 z) {
  #  real32 maxLevel = 0.0;
  #  real32 minLevel = -64.0;
  #  real32 scale = 0.1;
  #  
  #  real32 val = Noise2DFractal/noise(
  #    x: cast[real32](x) * scale,
  #    y: cast[real32](z) * scale,
  #    levels: 2,
  #    seed: 0
  #  );
  #  
  #  done cast[int32](minLevel + (val * (maxLevel - minLevel)));
  #}
  
  #func int32 earthLevel(int32 x, int32 y, int32 z) {
  #  real32 maxLevel = 4.0;
  #  real32 minLevel = 0.0;
  #  real32 scale = 0.1;
  #  
  #  real32 val = Noise2DFractal/noise(
  #    x: cast[real32](x) * scale,
  #    y: cast[real32](z) * scale,
  #    levels: 2,
  #    seed: 0
  #  );
  #  
  #  done cast[int32](minLevel + (val * (maxLevel - minLevel)));
  #}

  func generateChunk(PTR[Chunk] chunk) {
    System/print(s:STR"generate: ");
    System/print(i:DRF(chunk).chunkCoord.x);
    System/print(s:STR" ");
    System/print(i:DRF(chunk).chunkCoord.y);
    System/print(s:STR" ");
    System/print(i:DRF(chunk).chunkCoord.z);
    System/println();
    
    PTR[Block] blocks = RTP[PTR[Block]](REF(DRF(chunk).blocks));
    int32 y = 0;
    while (y < Chunk/SIZE) {
      int32 z = 0;
      while (z < Chunk/SIZE) {
        int32 x = 0;
        while (x < Chunk/SIZE) {
          PTR[Block] block = blocks + (z * Chunk/SIZE * Chunk/SIZE) + (y * Chunk/SIZE) + x;
          
          int32 bx = DRF(chunk).chunkCoord.x * Chunk/SIZE + x;
          int32 by = DRF(chunk).chunkCoord.y * Chunk/SIZE + y;
          int32 bz = DRF(chunk).chunkCoord.z * Chunk/SIZE + z;
          
          real32 stoneHeight = 70.0;
          real32 dirtHeight = 10.0;
          real32 totalHeight = stoneHeight + dirtHeight;
          
          int32 stoney = cast[int32]((0.0 - totalHeight) + (Noise2DFractal/noise(
            x: cast[real32](bx) * 0.07,
            y: cast[real32](bz) * 0.07,
            levels: 2,
            seed: 0
          ) * stoneHeight));
          
          int32 dirty = stoney + cast[int32]((Noise2DFractal/noise(
            x: cast[real32](bx) * 0.07,
            y: cast[real32](bz) * 0.07,
            levels: 2,
            seed: 0
          ) * dirtHeight));
          
          if (by < stoney) {
            DRF(block) = Blocks/BLOCK_STONE;
          } else if (by < dirty) {
            DRF(block) = Blocks/BLOCK_DIRT;
          } else {
            DRF(block) = Blocks/BLOCK_AIR;
          }
          
          #System/print(b: Block/isSolid(block: block));
          
          x = x + 1;
        }
        z = z + 1;
      }
      y = y + 1;
    }
  }

}

