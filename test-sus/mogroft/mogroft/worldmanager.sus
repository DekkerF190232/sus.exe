package mogroft/world/WorldManager {

  use mogroft/world/World;
  use mogroft/world/Block;
  use mogroft/world/Blocks;
  use mogroft/world/Chunk;
  use mogroft/world/ChunkList;
  use mogroft/world/ChunkCoordList;
  
  struct WorldManager (
    PTR[World] world,
    ChunkEventHandler chunkEventHandler
  );
  
  struct ChunkEventHandler(
    funcptr[(PTR[Chunk] chunk)] onLoaded
  );

  func WorldManager new(ChunkEventHandler chunkEventHandler) {
    done WorldManager(
      world = RTP[PTR[World]](0),
      chunkEventHandler = chunkEventHandler
    );
  }

  func loadExample(PTR[WorldManager] this) {
    PTR[World] world = World/alloc();
    DRF(this).world = world;

    DRF(world).player.position.z = 10.0;
    
    funcptr[(PTR[Chunk] chunk)] onLoadedFunc = DRF(this).chunkEventHandler.onLoaded;

    PTR[ChunkList] chunkList = REF(DRF(world).chunkList);

    PTR[Chunk] newChunk = ChunkList/add(this: chunkList);
    DRF(newChunk).chunkCoord = ChunkCoord(x = 0, y = 0, z = 0);
    generateChunk(chunk: newChunk);
    onLoadedFunc(chunk: newChunk);

    newChunk = ChunkList/add(this: chunkList);
    DRF(newChunk).chunkCoord = ChunkCoord(x = 0, y = -1, z = 0);
    generateChunk(chunk: newChunk);
    onLoadedFunc(chunk: newChunk);
  }

  func generateChunk(PTR[Chunk] chunk) {
    PTR[Block] blocks = RTP[PTR[Block]](REF(DRF(chunk).blocks));
    int32 x = 0;
    int32 y = 0;
    int32 z = 0;
    while (z < Chunk/SIZE) {
      while (y < Chunk/SIZE) {
        while (x < Chunk/SIZE) {
          PTR[Block] block = blocks + (z * Chunk/SIZE * Chunk/SIZE) + (y * Chunk/SIZE) + x;
          
          if (DRF(chunk).chunkCoord.y >= 0) {
            DRF(block) = Block/new(id: Blocks/ID_AIR);
          } else {
            DRF(block) = Block/new(id: Blocks/ID_STONE);
          }
          
          x = x + 1;
        }
        y = y + 1;
      }
      z = z + 1;
    }
  }

}

