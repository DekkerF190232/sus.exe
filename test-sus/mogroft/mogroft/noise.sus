# https://de.wikipedia.org/wiki/Perlin-Noise

package mogroft/Noise2D {

  use sus/Math;
  use mogroft/algebra/Vec2;

  func real32 interpolate(real32 a0, real32 a1, real32 x)
  {
      #real32 g = x; # lineare Interpolation; ergibt stetiges, aber nicht differenzierbares Rauschen
      #real32 g = ((x * (x * 6.0 - 15.0) + 10.0) * x * x * x); # Interpolation mit dem Polynom 6 * x^5 - 15 * x^4 + 10 * x^3
      real32 g = (3.0 - x * 2.0) * x * x; # kubische Interpolation mit dem Polynom 3 * x^2 - 2 * x^3
      done (a1 - a0) * g + a0;
  }
  
  func real32 dotGridGradient(int32 ix, int32 iy, real32 x, real32 y)
  {
    Vec2 grad = randomGradient(ix: ix, iy: iy);
    real32 dx = x - cast[real32](ix);
    real32 dy = y - cast[real32](iy);
    done dx * grad.x + dy * grad.y; # Skalarprodukt
  }
  
  func Vec2 randomGradient(int32 ix, int32 iy)
  {
    int8 w = cast[int8](8 * size[int32]());
    int8 s = cast[int8](4 * size[int32]());
    int8 wms = cast[int8](cast[int32](w) - cast[int32](s));
    
    int32 a = ix;
    int32 b = iy;
    a = a * 3284157443;
    b = b * ((a << s) | (a >> (wms)));
    b = b * 1911520717;
    a = a ^ ((b << s) | (b >> (wms)));
    a = a * 2048419325;
    
    # Erzeugt eine Zufallszahl im Intervall [0, 2 * Pi]
    real32 random = cast[real32](a) * Math/PI / cast[real32](~(~0 >> cast[int8](1))); 
    
    done Vec2(
      x = Math/cosf(x: random),
      y = Math/sinf(x: random)
    );
  }
  
  func real32 perlin(real32 x, real32 y) {
    real32 r = perlinUnnorm(x: x, y: y);
    r = (r + 0.7071068) / 1.4142137;
    if (r < 0.0000001) done 0.0000001;
    if (r > 0.9999999) done 0.9999999;
    done r;
  }
  
  # Diese Funktion berechnet den Wert des Perlin noise für den Punkt (x, y)
  # Das Ergebnis liegt im Intervall [-1/sqrt(2), 1/sqrt(2)]
  func real32 perlinUnnorm(real32 x, real32 y)
  {
    # Bestimme die Koordinaten der vier Ecken der Gitterzelle:
    int32 x0 = cast[int32](Math/floor(x: x));
    int32 x1 = x0 + 1;
    int32 y0 = cast[int32](Math/floor(x: y));
    int32 y1 = y0 + 1;

    # Bestimme die Abstände von den Gitterpunkten für die Interpolation:
    real32 sx = x - cast[real32](x0);
    real32 sy = y - cast[real32](y0);

    # Interpoliere zwischen den Skalarprodukten an den vier Ecken:
    real32 n0 = dotGridGradient(ix: x0, iy: y0, x:x, y:y);
    real32 n1 = dotGridGradient(ix: x1, iy: y0, x:x, y:y);
    real32 ix0 = interpolate(a0: n0, a1: n1, x: sx);
    n0 = dotGridGradient(ix: x0, iy: y1, x: x, y: y);
    n1 = dotGridGradient(ix: x1, iy: y1, x: x, y: y);
    real32 ix1 = interpolate(a0: n0, a1: n1, x: sx);

    done interpolate(a0: ix0, a1: ix1, x: sy);
  }

}