package mogroft/Texture {

  use sus/native/Win;
  use sus/System;
  use sus/File;
  use sus/Memory;
  use mogroft/Renderer;
  use sus/Gl;
  
  static int32 txTile1 = -1;
  
  func init() {
    txTile1 = loadTexture(file: STR"assets/tile1.bmp");
  }
  
  # note: using arrays, because of padding
  struct BitmapFileHeader (
    array[int8, 2] bfType,
    array[int8, 4] bfSize,
    array[int8, 2] bfReserved1,
    array[int8, 2] bfReserved2,
    array[int8, 4] bfOffBits
  );
  
  struct BitmapV3InfoHeader (
    int32 biSize,
    int32 biWidth,
    int32 biHeight,
    int32 biPlanes,
    int32 biBitCount,
    int32 biCompression,
    int32 biSizeImage,
    int32 biXPelsPerMeter,
    int32 biYPelsPerMeter,
    int32 biClrUsed,
    int32 biClrImportant
  );

  func int32 loadTexture(PTR[int8] file) {
    System/print(s: STR"Loading texture at \"");
    System/print(s: file);
    System/print(s: STR"\"");
    System/println();
    
    int32 width = 0;
    int32 height = 0;

    PTR[int8] fileData = RTP[PTR[int8]](0);
    PTR[int8] pixelData = loadBmpData(file: file, width: REF(width), height: REF(height), fileData: REF(fileData));

    #System/print(i: width);
    #System/println();
    #System/print(i: height);
    #System/println();
    #System/println();
    #System/printBytes(pointer: pixelData, count: 128);
    
    int32 textureId = 0;
    Gl/glGenTextures(n: 1, textures: REF(textureId));
    Gl/glBindTexture(target: Gl/GL_TEXTURE_2D, texture: textureId);
    Gl/glTexImage2D(
      target:         Gl/GL_TEXTURE_2D,
      level:          0,
      internalFormat: Gl/GL_RGBA,
      width:          width,
      height:         height,
      border:         0,
      format:         Gl/GL_RGBA,
      type:           Gl/GL_UNSIGNED_BYTE,
      pixels:         RTP[PTR[int8]](pixelData)
    );
    
    Gl/glTexParameteri(target: Gl/GL_TEXTURE_2D, pname: Gl/GL_TEXTURE_WRAP_S, param: Gl/GL_REPEAT);
    Gl/glTexParameteri(target: Gl/GL_TEXTURE_2D, pname: Gl/GL_TEXTURE_WRAP_T, param: Gl/GL_REPEAT);
    Gl/glTexParameteri(target: Gl/GL_TEXTURE_2D, pname: Gl/GL_TEXTURE_MIN_FILTER, param: Gl/GL_LINEAR);
    Gl/glTexParameteri(target: Gl/GL_TEXTURE_2D, pname: Gl/GL_TEXTURE_MAG_FILTER, param: Gl/GL_LINEAR);
    Gl/glBindTexture(target: Gl/GL_TEXTURE_2D, texture: 0);
    
    Gl/printError(location: STR"After loading texture");
    
    Memory/free(pointer: RTP[ptr](fileData));
    
    done textureId;
  }

  # loads a bitmapv3 argb 32-bit bmp, here is a guide to create such a file in gimp 2.10.28:
  #   - add an alpha channel to a layer
  #   - set mode to rgb and precision to int8 (default)
  #   - export the image as bmp
  #     - check "do not write color space information"
  #     - select 32 bits a8 r8 g8 b8 (default)
  #
  # - note 1: when reading, this function does not do any checks to see if the buffer was overrun.
  #   additionally, any issue handled (file not found, wrong format) will crash the program.
  # - note 2: the rows are not reversed, which means v texture coordinates are flipped.
  # 
  func PTR[int8] loadBmpData(PTR[int8] file, PTR[int32] width, PTR[int32] height, PTR[PTR[int8]] fileData) {
    PTR[int8] data = RTP[PTR[int8]](0);
    int32 dataLength = File/read(file: file, data: REF(data));

    DRF(fileData) = data;
    
    # read bitmap file header
    PTR[BitmapFileHeader] fileHeader = RTP[PTR[BitmapFileHeader]](data);
    int32 pixelDataOffset = RTP[int32](DRF(fileHeader).bfOffBits);
    
    # check if file is bitmap
    if (cast[int32](RTP[int16](DRF(fileHeader).bfType)) != @4D42) {
      int32 err = Win/GetLastError();
      System/print(s: STR"Not a bitmap file: \"");
      System/print(s: file);
      System/print(s: STR"\"");
      System/println();
      System/exit(code: err);
    }
    
    # read bitmap header v3
    PTR[BitmapV3InfoHeader] infoHeader = RTP[PTR[BitmapV3InfoHeader]](data + size[BitmapFileHeader]());
    int32 infoHeaderLength = DRF(infoHeader).biSize;
    DRF(width) = DRF(infoHeader).biWidth;
    DRF(height) = DRF(infoHeader).biHeight;

    # check header length
    if (infoHeaderLength != 56) {
      System/print(s:STR"Unsupported bitmap info header size: ");
      System/print(i: infoHeaderLength);
      System/println();
      System/exit(code: 1);
    }
    PTR[int8] pixelData = data + pixelDataOffset;

    # convert argb to rgba
    int32 i = 0;
    int32 pixels = DRF(width) * DRF(height);
    while (i < pixels) {
      PTR[int8] base = pixelData + (i * 4);
      
      array[int8, 4] argb = DRF(RTP[PTR[array[int8, 4]]](base));
      
      DRF(base) =   DRF(RTP[PTR[int8]](REF(argb)) + 2);
      DRF(base+1) = DRF(RTP[PTR[int8]](REF(argb)) + 1);
      DRF(base+2) = DRF(RTP[PTR[int8]](REF(argb)) + 0);
      DRF(base+3) = DRF(RTP[PTR[int8]](REF(argb)) + 3);

      i = i + 1;
    }


    #System/print(s: STR"Image dump after");
    #System/print(s: file);
    #System/print(s: STR":");
    #System/println();
    #System/printBytes(pointer: pixelData, count: 512);
    #System/println();

    done pixelData;
  }

  func int32 loadTextureOld(PTR[int8] file) {
    #
    # open file and get size
    #
    int32 handle = Win/CreateFileA(
      fileName: file,
      accessMode: Win/GENERIC_READ,
      shareMode: Win/FILE_SHARE_NONE,
      securityAttributes: RTP[ptr](0),
      creationMode: Win/OPEN_EXISTING,
      flagsAndAttributes: 0,
      templateFileHandle: 0
    );
    if (handle == 0) {
      int32 err = Win/GetLastError();
      System/print(s: STR"Error opening file \"");
      System/print(s: file);
      System/print(s: STR"\": ");
      System/println(i: err);
      System/exit(code: err);
    }
    LargeInteger fileSize = Win/new_LargeInteger();
    boo gotSize = Win/GetFileSizeEx(
      file: handle,
      fileSize: REF(fileSize)
    );
    if (fileSize.high != 0) {
      System/print(s: STR"Error opening file \"");
      System/print(s: file);
      System/print(s: STR"\": ");
      System/println(s: STR"File to big.");
      System/exit(code: 123);
    }
    System/print(s: STR"Loading texture at \"");
    System/print(s: file);
    System/print(s: STR"\" (");
    System/print(i: fileSize.low);
    System/print(s: STR" bytes)");
    System/println();
    
    #
    # read file
    #
    System/println(i: handle);
    PTR[int8] buffer = RTP[PTR[int8]](Memory/malloc(bytes: fileSize.low));
    boo read = Win/ReadFile(
      fileHandle: handle,
      buffer: buffer,
      toRead: fileSize.low,
      actualRead: RTP[PTR[int32]](0),
      overlapped: RTP[ptr](0)
    );
    System/println(s: STR"read file");
    if (read == no) {
      int32 err = Win/GetLastError();
      System/print(s: STR"Error reading file \"");
      System/print(s: file);
      System/print(s: STR"\": ");
      System/println(i: err);
      System/exit(code: err);
    }
    boo _1 = Win/CloseHandle(handle: handle);
    
    #
    # interpret bitmap:
    #
    PTR[int8] current = buffer;
    
    #PTR[BmpHeader] header = RTP[PTR[BmpHeader]](current);
    #System/println(i: DRF(header).width);
    #System/println(i: DRF(header).height);
    
    System/printBytes(pointer: current, count: 128);
    
    #PTR[BitmapHeader] header = RTP[PTR[BitmapHeader]](current);
    #current = current + size[BitmapHeader]();
    #current = current + size[BitmapHeader]();
    
    #if (cast[int32](DRF(header).type) != @4D42) {
    #  int32 err = Win/GetLastError();
    #  System/print(s: STR"Not a bitmap file: \"");
    #  System/print(s: file);
    #  System/println(s: STR"\"");
    #  System/exit(code: err);
    #}
    
    
    #System/print(s: STR"bitmap info offset: ");
    #System/println(i: RTP[int32](current - buffer));
    
    #if (infoLength != 124) {
    #  int32 err = Win/GetLastError();
    #  System/print(s: STR"Not a BITMAPV5HEADER file: \"");
    #  System/print(s: file);
    #  System/print(s: STR"\"(");
    #  System/print(i: infoLength);
    #  System/println(s: STR")");
    #  System/exit(code: err);
    #}
    
    #PTR[BitmapInfoHeader] info = RTP[PTR[BitmapInfoHeader]](current);
    #int32 infoLength = DRF(RTP[PTR[int32]](current));
    #current = current + infoLength;
    #System/println(i_0x: DRF(info).length);
    
    #PTR[int16] bitCount = REF(DRF(info).bitCount);
    #System/print(s: STR"bitCount offset: ");
    #System/println(i: RTP[int32](RTP[int32](bitCount) - buffer));
    #if (cast[int32](DRF(info).bitCount) != 32) {
    #  int32 err = Win/GetLastError();
    #  System/print(s: STR"Bitmap does not have 32-bit format: \"");
    #  System/print(s: file);
    #  System/print(s: STR"\" (");
    #  System/print(i_0x: cast[int32](DRF(info).bitCount));
    #  System/println(s: STR")");
    #  System/exit(code: err);
    #}
    
    #if (DRF(info).compression != 0) {
    #  int32 err = Win/GetLastError();
    #  System/print(s: STR"Bitmap is compressed: \"");
    #  System/print(s: file);
    #  System/print(s: STR"\" (");
    #  System/print(i: DRF(info).compression);
    #  System/println(s: STR")");
    #  System/exit(code: err);
    #}
    
    #current = buffer + 50;
    #
    #int32 width = DRF(header).width;
    #int32 height = DRF(header).height;
    #PTR[int32] result = ARR[int32](1024);
    #int32 y = 0;
    #while (y < height) {
    #  int32 x = 0;
    #  while (x < width) {
    #    PTR[int32] dest = RTP[PTR[int32]](result) + ((height - 1 - y) * width) + x;
    #    PTR[int32] src = RTP[PTR[int32]](current) + (y * width) + x;
    #    
    #    DRF(dest) = DRF(src);
    #    
    #    x = x + 1;
    #  }
    #  y = y + 1;
    #}
    
    #int32 textureId = 0;
    #Gl/glGenTextures(n: 1, textures: REF(textureId));
    #Gl/glBindTexture(target: Gl/GL_TEXTURE_2D, texture: textureId);
    #
    #Gl/glTexImage2D(
    #  target:         Gl/GL_TEXTURE_2D,
    #  level:          0,
    #  internalFormat: Gl/GL_RGBA,
    #  width:          width,
    #  height:         height,
    #  border:         0,
    #  format:         Gl/GL_RGBA,
    #  type:           Gl/GL_UNSIGNED_BYTE,
    #  pixels:         RTP[PTR[int8]](current)
    #);
    #
    #Gl/glTexParameteri(target: Gl/GL_TEXTURE_2D, pname: Gl/GL_TEXTURE_WRAP_S, param: Gl/GL_REPEAT);
    #Gl/glTexParameteri(target: Gl/GL_TEXTURE_2D, pname: Gl/GL_TEXTURE_WRAP_T, param: Gl/GL_REPEAT);
    #Gl/glTexParameteri(target: Gl/GL_TEXTURE_2D, pname: Gl/GL_TEXTURE_MIN_FILTER, param: Gl/GL_LINEAR);
    #Gl/glTexParameteri(target: Gl/GL_TEXTURE_2D, pname: Gl/GL_TEXTURE_MAG_FILTER, param: Gl/GL_LINEAR);
    #
    #Gl/glBindTexture(target: Gl/GL_TEXTURE_2D, texture: 0);
    #
    #done textureId;
    Memory/free(pointer: RTP[ptr](buffer));
    done 0;
  }

}